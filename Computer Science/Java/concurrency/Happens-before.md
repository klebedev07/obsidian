*В* частности, одно выполняется прежде другого для таких операций (список не исчерпывающий):

- Синхронизация и [[monitor(concurrency)]]
    - Захват монитора (начало `synchronized`, метод `lock`) и всё, что после него в том же потоке.
    - Возврат монитора (конец `synchronized`, метод `unlock`) и всё, что перед ним в том же потоке.
        - Таким образом, оптимизатор может заносить строки в синхроблок, но не наружу.
    - Возврат монитора и последующий захват другим потоком.
- Запись и чтение:
    - Любые зависимости по данным (то есть запись в любую переменную и последующее чтение её же) в одном потоке.
    - Всё, что в том же потоке перед записью в `volatile`-переменную, и сама запись.
    - `volatile`-чтение и всё, что после него в том же потоке.
    - Запись в `volatile`-переменную и последующее считывание её же). Таким образом, `volatile`-запись делает с памятью то же, что возврат монитора, а чтение — то же, что захват). А значит: если один поток записал в `volatile`-переменную, а второй обнаружил это, всё, что предшествует записи, выполняется раньше всего, что идёт после чтения; см. иллюстрацию.
        - Для объектных переменных (например, `volatile List x;`) столь сильные гарантии выполняются для ссылки на объект, но не для его содержимого.
- Обслуживание объекта:
    - Статическая инициализация и любые действия с любыми экземплярами объектов.
    - Запись в `final`-поля в конструктореи всё, что после конструктора. Как исключение из всеобщей транзитивности, это соотношение _happens-before_ не соединяется транзитивно с другими правилами и поэтому может вызвать межпоточную гонку.
    - Любая работа с объектом и `finalize()`.
- Обслуживание потока:
    - Запуск потока и любой код в потоке.
    - Зануление переменных, относящихся к потоку, и любой код в потоке.
    - Код в потоке и `join()`; код в потоке и `isAlive() == false`.
    - `interrupt()` потока и обнаружение факта останова.![[Pasted image 20230526163315.png]]


так же писано подробно [[Memory Model гарантии для concurrency]]