АОП — аспектно-ориентированное программирование — это парадигма, направленная на повышение модульности различных частей приложения за счет разделения сквозных задач. Для этого к уже существующему коду добавляется дополнительного поведение, без изменений в изначальном коде.

Аспектно-ориентированное программирование предназначено для решения сквозных задач, которые могут представлять собой любой код, многократно повторяющийся разными методами, который нельзя полностью структурировать в отдельный модуль.

 Аспекты — это вынесенный отдельно код, который можно многократно переиспользовать и улучшать.

Пример
```Java
@Aspect
public class GreetingAspect{ 
	
	@Pointcut("execution(* Main.printName(String))") 
	public void greeting() { } 
	
	@Before("greeting()") 
	public void beforeAdvice() { System.out.print("Привет "); } 

	@Around(value = "executeOperation()") 
	public void beforeAdvice(ProceedingJoinPoint joinPoint) {
		System.out.println("Открытие транзакции..."); 
		try { 
			joinPoint.proceed(); 
			System.out.println("Закрытие транзакции...."); 
		} catch (Throwable throwable) { 
			System.out.println("Операция не удалась, откат транзакции..."); }
	 }	
}
```

## Основные понятия АОП

Чтобы продвинуться дальше в разборе темы, для начала познакомимся с главными понятиями АОП.

Совет (advice) — это дополнительная логика, код, который вызывается из точки соединения. Совет может быть выполнен до, после или вместо точки соединения (о них — ниже). Возможные виды советов:

1. Перед (Before) — советы данного типа запускаются перед выполнением целевых методов — точек соединения. При использовании аспектов в виде классов мы берем @Before аннотацию, чтобы пометить тип совета как идущий перед. При использовании аспектов в виде файлов .aj это будет метод before().
2. После (After) — советы, которые выполняются после завершения выполнения методов — точек соединения, как в обычных случаях, так и при бросании исключения.  
    При использовании аспектов в виде классов мы можем использовать @After аннотацию для указания, что это совет, идущий после.  
    При использовании аспектов в виде файлов .aj это будет метод after().
3. После возврата (After Returning) — данные советы выполняются только в том случае, когда целевой метод отрабатывает нормально, без ошибок.  
    Когда аспекты представлены в виде классов, мы можем использовать аннотацию @AfterReturning, чтобы пометить совет как выполняемый после успешного завершения.  
    При использовании аспектов в виде файлов .aj это будет метод after() returning (Object obj).
4. После бросания (After Throwing) — данный вид советов предназначен для тех случаев, когда метод, то есть точка соединения выдает исключение. Мы можем использовать этот совет для некой обработки неудачного выполнения (к примеру, для отката всей транзакции или логирования с необходимым уровнем трассировки).  
    Для аспектов-классов аннотация @AfterThrowing используется, чтобы указать, что этот совет используется при после броска исключения.  
    При использовании аспектов в виде файлов .aj это будет метод — after() throwing (Exception e).
5. Вокруг (Around) — пожалуй, один из самых важных видов советов, который окружает метод, то есть — точку соединения, с помощью которого мы можем, к примеру, выбрать, выполнять данный метод точки соединения или нет.  
    Можно написать код совета, который будет выполняться до и после выполнения метода точки соединения.  
    В обязанности around advice входит вызов метода точки соединения и возвращение значений, если метод что-то возвращает. То есть в этом совете можно попросту сымитировать работу целевого метода, не вызывая его, и в качестве результата вернуть что-то свое.  
    При аспектах в виде классов используем @Around аннотацию для создания советов, оборачивающих точку соединения. При использовании аспектов в виде файлов .aj это будет метод around().

Точка соединения (join point) — точка в выполняемой программе (вызов метода, создание объекта, обращение к переменной), где следует применить совет. Иначе говоря, это некоторое регулярное выражение, с помощью которого и находятся места для внедрения кода (места для применения советов). 

Срез (pointcut) — набор точек соединения. Срез определяет, подходит ли данная точка соединения к данному совету. 

Аспект (aspect) — модуль или класс, реализующий сквозную функциональность. Аспект изменяет поведение остального кода, применяя совет в точках соединения, определенных некоторым срезом. Иными словами, это комбинация советов и точек соединения. 

Внедрение (introduction) — изменение структуры класса и/или изменение иерархии наследования для добавления функциональности аспекта в инородный код. Цель (target) — объект, к которому будут применяться советы. 

Плетение (weaving) — это процесс связывания аспектов с другими объектами для создания рекомендуемых прокси-объектов. Это можно сделать во время компиляции, загрузки или во время выполнения. Есть три вида плетения:
- плетение во время компиляции — если у вас есть исходный код аспекта и код, в котором вы используете аспекты, вы можете скомпилировать исходный код и аспект напрямую с помощью компилятора AspectJ;
- посткомпиляционное плетение (бинарное плетение) — если вы не можете или не хотите использовать преобразования исходного кода для вплетения аспектов в код, вы можете взять уже скомпилированные классы или jar-файлы и внедрить аспекты;
- плетение во время загрузки — это просто бинарное плетение, отложенное до момента, когда загрузчик классов загрузит файл класса и определит класс для JVM.  
    Для поддержки этого требуется один или несколько «загрузчиков классов плетения». Они либо явно предоставляются средой выполнения, либо активируются с помощью «агента плетения.