  
**1. Инстанцирование объекта**. Техническое начало жизни бина, работа конструктора его класса;  
  
**2. Установка свойств** из конфигурации бина, [внедрение зависимостей](https://itsobes.ru/JavaSobes/kak-spring-framework-realizuet-pattern-dependency-injection);  
  
**3. Нотификация aware-интерфейсов**. `BeanNameAware`, `BeanFactoryAware` и другие. Мы уже писали о таких интерфейсах [ранее](https://itsobes.ru/JavaSobes/kogda-ispolzuiut-aware-interfeisy-v-spring). Технически, выполняется системными подтипами `BeanPostProcessor`, и совпадает с шагом 4;  
  
**4. Пре-инициализация** – метод `postProcessBeforeInitialization()` интерфейса `BeanPostProcessor`;  
  
**5. Инициализация.** Разные способы применяются в таком порядке:  
**•** Метод бина с аннотацией `@PostConstruct` из стандарта JSR-250 (рекомендуемый способ);  
**•** Метод `afterPropertiesSet()` бина под интерфейсом `InitializingBean`;  
**•** Init-метод. Для отдельного бина его имя устанавливается в параметре определения `initMethod`. В xml-конфигурации можно установить для всех бинов сразу, с помощью `default-init-method`;  
  
**6. Пост-инициализация** – метод `postProcessAfterInitialization()` интерфейса `BeanPostProcessor`.

Когда IoC-контейнер завершает свою работу, мы можем кастомизировать этап штатного уничтожения бина. Как со всеми способами [финализации](https://itsobes.ru/JavaSobes/finalize) в Java, при жестком выключении (`kill -9`) гарантии вызова этого этапа нет. Три альтернативных способа «деинициализации» вызываются в том же порядке, что симметричные им методы инициализации:  
  
**1.** Метод с аннотацией `@PreDestroy`;  
**2.** Метод с именем, которое указано в свойстве `destroyMethod` определния бина (или в глобальном `default-destroy-method`);  
**3.** Метод `destroy()` интерфейса `DisposableBean`.  
  
Не следует путать жизненный цикл отдельного бина с жизненным циклом контекста и этапами подготовки фабрик бинов. О них мы поговорим в будущих публикациях.
